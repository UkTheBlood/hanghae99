동기 비동기
동기적 실행: 순차적으로 작업이 실행되는데, 이전 작업이 실행 중이라면 다음 작업을 실행할 수 없음.
이전 작업의 실행 결과가 필요할 때 적합하며 JS는 일반적으로 동기 실행을 기반

비동기적 실행: 비 순차적으로 작업을 실행하는데, 이전 작업의 실행 여부가 다음 작업에 영향이 없음
작업이 완료 되는데 시간이 걸림.

자바스크립트 엔진은 싱글 스레드로 동작한다. 

프로그램: 어떤 작업을 위해 실행할 수 있는 파일이며, 해당 파일이 실행되면 하나의 프로세스가 실행된다.
프로세스가 실행되면 운영체제로부터 시스템 자원(메모리와 연산 능력)을 할당 받는다. 
이러한 자원을 통해 프로그램이 컴퓨터에서 연속적으로 프로세스를 실행 할 수 있게 되는 것이다.
프로세스:  실행된 프로그램을 얘기하는데, 하나의 프로세스 내에서 실행되는 흐름의 단위로 스레드가 있다.
일반적으로 스레드는 "일꾼"으로 비유된다. 
컴파일: 프로세스가 수행할 코드가 프로그래밍 언어로 작성되어 기계어로 번역되어 순차적으로 실행하는 과정
/* 자바스크립트의 특징 */
- 일반적으로 프로그래밍 언어로 작성된 프로그램이 프로세스가 되기 위해서는 "운영체제"로 부터
시스템의 자원을 할당받아야 하는데, 자바스크립트에서는 프로세스와 운영체제 사이에 "브라우저"가 존재

즉. 자바스크립트는 싱글 스레드로 동작하며, 하나의 일꾼을 가지고 우리가 작성한 코드를 수행한다.

자바스크립트 엔진은 싱글 스레도르 동작하지만, 비동기 처리를 하기 위해 별도의 스레드가 존재한다.
별도의 스레드 "브라우저"

자바스크립트 비동기 런타임 과정

Call Stack: 자바스크립트에서 수행해야 할 함수를 순차적으로 스택에 담아 처리
 - a,b,c,d의 순서로 넣으면 역순으로 d,c,b,a로 나옴
Wep API: 웹 브라우저에서 제공하는 API, AJAX나 Timeout등의 비동기 작업을 실행
Task(Callback) Queue: Web aPI에서 넘겨받은 Callback 함수를 저장
Event Loop: Call Stack이 비어있으면 Task Queue의 작업을 Call Stack으로 옮김

JS는 엔진이 단 하나의 Call Stack으로 코드를 실행하기 때문에 기본적으로 동기 실행 언어지만
비동기적 실행이 불가능한 것은 아님
- Task(Callback) Queue와 Event Loop의 도움이 필요

순서
1. Call Stack에서 동기작으로 작업을 실행하며 필요에 따라 Web API를 호출한다.
2. Web API는 여러 스레드를 이용해 비동기적으로 작업을 실행하고, 작업이 완료되면 
Task(Callback) Queue로 전달한다.
3. Event Loop가 Call Stack에 작업이 모두 다 마치고 비어있으면 
Task(Callback) Queue를 하나씩 Call Stack에 추가한다

자바스크립트가 싱글 스레드를 사용하는 이유
- '쉬워서'
만약 멀티 스레드로 실행하게 되면 웹 페이지에서 발생하는 동시성의 문제에 대해 해결해야 한다.
단일 스레드로 실행되기 때문에 다중 스레드 환경에서 발생할 수 있는 복잡한 시나리오를 신경 쓸 필요가
없으며 비동기 처리를 통해 쉽게 여러 요청이 가능하다. 

결론
- 자바스크립트는 싱글스레드로 동기 실행을 하지만, "브라우저"를 통해 비동기 처리가 지원된다.

#################################################################
#################################################################

1. promise
제작 코드(executor): 원격에스 스크립트를 불러오는 것 같은 시간 걸리는 일
소비 코드: '제작 코드'의 결과를 기다렸다가 이를 소비하는 것, 이때 소비 주체는 여럿이 될 수 있음
프로미스: '제작 코드'와 '소비 코드'를 연결 해주는 특별한 자바스크립트 객체
	시간이 얼마나 걸리든 상관 없이 약속한 결과를 만들어 내는 '제작 코드'가 준비 되었을 때,
	모든 소비 코드가 결과를 사용할 수 있도록 해줌

중점
1. state: 상태, operation을 수행하고 있는지, 아니면 기능 수행이 완료가 다 되어 성공했는지 실패했는지
2. 우리가 원하는 데이터를 제공하는 사람(프로듀서)과 이 제공된 데이터를 쓰는 사람(컨슈머)의 차이점

state: 프로미스가 만들어져 우리가 지정한 오퍼레이션이 수행중일 때 pending 상태
성공적으로 끝난 경우 fulfilled 상태 or 문제가 생기면 reject 상태

network와의 통신, read files은 비동기적으로 실행하는 것이 좋음

Producer vs Consumer

** 새로운 프로미스가 만들어질 때는 새로운 executor라는 함수가 자동적으로 바로 실행이 됨 **
** executor은 보통 시간이 걸리는 일을 수행하는데, 일이 끝나면 resolve 혹은 reject 함수를 호출 **
  // 이때 promise의 객체 상태가 변화함
** 이행(resolve) 혹은 거부(rejected) 상태의 프라미스는 '처리된(settled)'프라미스라고 부름 **
** 이행 혹은 거부 상태의 전 즉, 반대되는 프라미스는 위에 말한 '대기(pending)' 상태 **
** 프라미스는 성공 또는 실패만 함 **

1) then
promise.then(
  function(result) { /* 결과(result)를 다룹니다 */ },
  function(error) { /* 에러(error)를 다룹니다 */ }
);

.then의 첫 번째 인수는 프라미스가 이행되었을 때 시행
.then의 두 번째 인수는 프라미스가 거부되었을 때 시행

성공적으로 처리된 경우만 다루고 싶은 경우 첫 번째 인수만 전달
then에 기록된 각 함수는 단 한 번만 호출



2) catch
에러가 발생한 경우만 다루고 싶은 경우 catch를 사용
 -> .catch는 .then에 null을 전달하는 것과 동일하게 작동

let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("에러 발생!")), 1000);
});

// .catch(f)는 promise.then(null, f)과 동일하게 작동합니다
promise.catch(alert); // 1초 뒤 "Error: 에러 발생!" 출력

** .catch(f)는 문법이 간결하다는 점만 빼면 .then(f, null)과 완벽하게 같음 **

3) finally
프라미스가 처리되면 f가 항상 실행된다는 점에서 .finally(f) 는 .then(f, f)와 유사
쓸모가 없어진 로딩 인디케이터(loading indicator)를 멈추는 경우같이
결과가 어떻게든 마무리가 필요하면 finally가 유용

.finally(f) 와 .then(f, f) 차이점

1. finally 핸들러엔 인수가 없어 프라미스가 이행되었는지 거부되었는지 알 수 없음.
2. finally 핸들러는 자동으로 다음 핸들러에 결과와 에러 전달
finally는 결과를 처링하려 만들어진 것이 아님.

// 처리된 프라미스의 핸들러는 즉각 실행 
// 일반적으로 .then에 두 가지 함수를 전달하는 경우는 별로 없음, .catch와 같이 쓰임
// 프라미스는 절대 이행과 거부가 동시에 일어날 수 없음
// 완료된 프라마스는 절대 이행이나 거부 상태로 바뀔 수 없음

2. promise chain

중요!!!! 비동기 작업 시퀸스를 .then의 체인으로 이어 콜백 지옥을 방지

.fetch().then().then()
표현식 하나에 메서드를 하나 이상 호출하는 것을 메서드 체인이라고 부름
- 메서드 체인을 사용하도록 돼 있는 API는 객체 하나만 존재하고, 
그 객체의 각 매서드는 객체 자체를 반환하는 형태가 일반적

//프라미스는 다름
- .then() 을 체인으로 호출할 때 프라미스 객체 하나에 여러개의 콜백을 등록하지 않음.
- .then() 메서드를 호출할 때 마다 새로운 프라미스 객체를 반환하며, 
새 프라미스 객체는 then()에 전달된 함수가 완료되기 전에는 이행되지 않음

promise를 중첩하여 사용하지 말고 연속적인 체인으로 사용

promise
  .then(f1)
  .catch(f2);

promise
  .then(f1, f2);

//첫 번째 코드는 .catch()에서 에러가 처리되지만, 
두 번째 코드는 에러를 처리할 수 없는 차이점이 생김

프라미스화
- 콜백 함수를 프라미스로 반환하는 함수로 바꾸는 것
- 콜백 지옥을 프라미스로 바꾸는 것

################################################################

async & await
프로미스를 조금 더 간결하고 간편하게
동기식 처럼 코드를 순서대로 작성할 수 있도록 만들어줌
함수 앞에 async 를 붙이면 해당 함수는 항상 프라미스를 반환

async function fetchUser() {
        resolve('ellie');
}

const user = fetchUser();
user.then(console.log)
console.log(user)

await은 async가 붙은 함수에만 사용 가능






























